"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/components/Whiteboard.tsx":
/*!***************************************!*\
  !*** ./app/components/Whiteboard.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Whiteboard; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction Whiteboard(param) {\n    let { socket, studentId, classCode, isTeacher, onBoardClick } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [isDrawing, setIsDrawing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [color, setColor] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"#000000\");\n    const [tool, setTool] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"draw\");\n    const [lastPoint, setLastPoint] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Set fixed dimensions\n        const width = 800;\n        const height = 600;\n        // Set the canvas size in actual pixels\n        canvas.width = width;\n        canvas.height = height;\n        // Set white background\n        ctx.fillStyle = \"#ffffff\";\n        ctx.fillRect(0, 0, width, height);\n        // Request initial canvas state if we're a teacher viewing a student's board\n        if (isTeacher) {\n            socket.emit(\"request-canvas-state\", {\n                classCode,\n                studentId\n            });\n        }\n        // Handle receiving draw updates\n        socket.on(\"draw-update-received\", (param)=>{\n            let { studentId: drawingStudentId, drawData, canvasState } = param;\n            if (drawingStudentId === studentId) {\n                if (canvasState) {\n                    loadCanvasState(canvasState);\n                } else if (drawData) {\n                    drawOnCanvas(drawData);\n                }\n            }\n        });\n        // Handle receiving full canvas state\n        socket.on(\"canvas-state-update\", (param)=>{\n            let { studentId: updatedStudentId, canvasState } = param;\n            if (updatedStudentId === studentId && canvasState) {\n                loadCanvasState(canvasState);\n            }\n        });\n        // Handle loading saved canvas state\n        socket.on(\"load-canvas\", (param)=>{\n            let { studentId: loadStudentId, canvasData } = param;\n            if (loadStudentId === studentId && canvasData) {\n                loadCanvasState(canvasData);\n            }\n        });\n        return ()=>{\n            socket.off(\"draw-update-received\");\n            socket.off(\"canvas-state-update\");\n            socket.off(\"load-canvas\");\n        };\n    }, [\n        socket,\n        studentId,\n        classCode,\n        isTeacher\n    ]);\n    const loadCanvasState = (canvasState)=>{\n        const canvas = canvasRef.current;\n        const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext(\"2d\");\n        if (!canvas || !ctx) return;\n        const img = new Image();\n        img.onload = ()=>{\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.drawImage(img, 0, 0);\n        };\n        img.src = canvasState;\n    };\n    const drawOnCanvas = (drawData)=>{\n        var _drawData_points;\n        const canvas = canvasRef.current;\n        const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext(\"2d\");\n        if (!canvas || !ctx || !(drawData === null || drawData === void 0 ? void 0 : (_drawData_points = drawData.points) === null || _drawData_points === void 0 ? void 0 : _drawData_points.length)) return;\n        ctx.beginPath();\n        ctx.moveTo(drawData.points[0].x, drawData.points[0].y);\n        // Smoother line when drawing\n        if (drawData.type === \"erase\") {\n            ctx.globalCompositeOperation = \"destination-out\";\n            ctx.strokeStyle = \"rgba(0,0,0,1)\";\n        } else {\n            ctx.globalCompositeOperation = \"source-over\";\n            ctx.strokeStyle = drawData.color;\n        }\n        ctx.lineWidth = 4; // Increased line width for clarity\n        ctx.lineCap = \"round\"; // Rounded cap for smooth edges\n        ctx.lineJoin = \"round\"; // Rounded joins for smooth corners\n        for(let i = 1; i < drawData.points.length; i++){\n            ctx.lineTo(drawData.points[i].x, drawData.points[i].y);\n        }\n        ctx.stroke();\n        ctx.closePath();\n        // Reset composite operation\n        ctx.globalCompositeOperation = \"source-over\";\n    };\n    const getCanvasCoordinates = (e)=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return null;\n        const rect = canvas.getBoundingClientRect();\n        const scaleX = canvas.width / rect.width;\n        const scaleY = canvas.height / rect.height;\n        return {\n            x: (e.clientX - rect.left) * scaleX,\n            y: (e.clientY - rect.top) * scaleY\n        };\n    };\n    const handlePointerDown = (e)=>{\n        if (isTeacher) {\n            if (onBoardClick) onBoardClick();\n            return;\n        }\n        const coords = getCanvasCoordinates(e);\n        if (!coords) return;\n        setIsDrawing(true);\n        setLastPoint(coords);\n        const drawData = {\n            points: [\n                coords\n            ],\n            color: tool === \"erase\" ? \"#ffffff\" : color,\n            width: 4,\n            type: tool\n        };\n        drawOnCanvas(drawData);\n    };\n    const handlePointerMove = (e)=>{\n        if (!isDrawing || isTeacher || !lastPoint) return;\n        const coords = getCanvasCoordinates(e);\n        if (!coords) return;\n        const drawData = {\n            points: [\n                lastPoint,\n                coords\n            ],\n            color: tool === \"erase\" ? \"#ffffff\" : color,\n            width: 4,\n            type: tool\n        };\n        drawOnCanvas(drawData);\n        // Get current canvas state\n        const canvas = canvasRef.current;\n        if (canvas) {\n            const canvasState = canvas.toDataURL();\n            // Emit both the draw data and canvas state\n            socket.emit(\"draw-update\", {\n                classCode,\n                studentId,\n                drawData,\n                canvasState\n            });\n        }\n        setLastPoint(coords);\n    };\n    const handlePointerUp = ()=>{\n        setIsDrawing(false);\n        setLastPoint(null);\n        // Send final canvas state when drawing ends\n        const canvas = canvasRef.current;\n        if (canvas && !isTeacher) {\n            const canvasState = canvas.toDataURL();\n            socket.emit(\"draw-update\", {\n                classCode,\n                studentId,\n                drawData: null,\n                canvasState\n            });\n        }\n    };\n    const clearCanvas = ()=>{\n        const canvas = canvasRef.current;\n        const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext(\"2d\");\n        if (!canvas || !ctx) return;\n        ctx.fillStyle = \"#ffffff\";\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // Send cleared canvas state\n        const canvasState = canvas.toDataURL();\n        socket.emit(\"draw-update\", {\n            classCode,\n            studentId,\n            drawData: null,\n            canvasState\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative border border-input rounded-lg shadow-md\",\n        onClick: onBoardClick,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: canvasRef,\n                className: \"touch-none w-full h-full rounded-lg\",\n                style: {\n                    aspectRatio: \"4/3\"\n                },\n                onPointerDown: handlePointerDown,\n                onPointerMove: handlePointerMove,\n                onPointerUp: handlePointerUp,\n                onPointerLeave: handlePointerUp\n            }, void 0, false, {\n                fileName: \"/Users/alexlautin/Documents/GitHub/emoryhacks25/app/components/Whiteboard.tsx\",\n                lineNumber: 232,\n                columnNumber: 7\n            }, this),\n            !isTeacher && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute bottom-4 left-4 flex gap-2 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 p-2 rounded-lg shadow-md border border-input\"\n            }, void 0, false, {\n                fileName: \"/Users/alexlautin/Documents/GitHub/emoryhacks25/app/components/Whiteboard.tsx\",\n                lineNumber: 242,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/alexlautin/Documents/GitHub/emoryhacks25/app/components/Whiteboard.tsx\",\n        lineNumber: 231,\n        columnNumber: 5\n    }, this);\n}\n_s(Whiteboard, \"TPLaNqvVcBGhXugcjIuzkk+M7mI=\");\n_c = Whiteboard;\nvar _c;\n$RefreshReg$(_c, \"Whiteboard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL1doaXRlYm9hcmQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUVvRDtBQWdCckMsU0FBU0csV0FBVyxLQUEwRTtRQUExRSxFQUFFQyxNQUFNLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVDLFlBQVksRUFBbUIsR0FBMUU7O0lBQ2pDLE1BQU1DLFlBQVlSLDZDQUFNQSxDQUFvQjtJQUM1QyxNQUFNLENBQUNTLFdBQVdDLGFBQWEsR0FBR1QsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDVSxPQUFPQyxTQUFTLEdBQUdYLCtDQUFRQSxDQUFDO0lBQ25DLE1BQU0sQ0FBQ1ksTUFBTUMsUUFBUSxHQUFHYiwrQ0FBUUEsQ0FBbUI7SUFDbkQsTUFBTSxDQUFDYyxXQUFXQyxhQUFhLEdBQUdmLCtDQUFRQSxDQUFrQztJQUU1RUYsZ0RBQVNBLENBQUM7UUFDUixNQUFNa0IsU0FBU1QsVUFBVVUsT0FBTztRQUNoQyxJQUFJLENBQUNELFFBQVE7UUFFYixNQUFNRSxNQUFNRixPQUFPRyxVQUFVLENBQUM7UUFDOUIsSUFBSSxDQUFDRCxLQUFLO1FBRVYsdUJBQXVCO1FBQ3ZCLE1BQU1FLFFBQVE7UUFDZCxNQUFNQyxTQUFTO1FBRWYsdUNBQXVDO1FBQ3ZDTCxPQUFPSSxLQUFLLEdBQUdBO1FBQ2ZKLE9BQU9LLE1BQU0sR0FBR0E7UUFFaEIsdUJBQXVCO1FBQ3ZCSCxJQUFJSSxTQUFTLEdBQUc7UUFDaEJKLElBQUlLLFFBQVEsQ0FBQyxHQUFHLEdBQUdILE9BQU9DO1FBRTFCLDRFQUE0RTtRQUM1RSxJQUFJaEIsV0FBVztZQUNiSCxPQUFPc0IsSUFBSSxDQUFDLHdCQUF3QjtnQkFBRXBCO2dCQUFXRDtZQUFVO1FBQzdEO1FBRUEsZ0NBQWdDO1FBQ2hDRCxPQUFPdUIsRUFBRSxDQUFDLHdCQUF3QjtnQkFBQyxFQUFFdEIsV0FBV3VCLGdCQUFnQixFQUFFQyxRQUFRLEVBQUVDLFdBQVcs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L1doaXRlYm9hcmQudHN4PzU3MzUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTb2NrZXQgfSBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcbmltcG9ydCB7IERyYXdEYXRhIH0gZnJvbSAnQC90eXBlcy9zb2NrZXQnO1xuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSBcIkAvY29tcG9uZW50cy91aS9idXR0b25cIjtcbmltcG9ydCB7IFRvb2x0aXAsIFRvb2x0aXBDb250ZW50LCBUb29sdGlwUHJvdmlkZXIsIFRvb2x0aXBUcmlnZ2VyIH0gZnJvbSBcIkAvY29tcG9uZW50cy91aS90b29sdGlwXCI7XG5pbXBvcnQgeyBQb3BvdmVyLCBQb3BvdmVyQ29udGVudCwgUG9wb3ZlclRyaWdnZXIgfSBmcm9tIFwiQC9jb21wb25lbnRzL3VpL3BvcG92ZXJcIjtcbmltcG9ydCB7IFNlcGFyYXRvciB9IGZyb20gXCJAL2NvbXBvbmVudHMvdWkvc2VwYXJhdG9yXCI7XG5cbmludGVyZmFjZSBXaGl0ZWJvYXJkUHJvcHMge1xuICBzb2NrZXQ6IFNvY2tldDtcbiAgc3R1ZGVudElkOiBzdHJpbmc7XG4gIGNsYXNzQ29kZTogc3RyaW5nO1xuICBpc1RlYWNoZXI/OiBib29sZWFuO1xuICBvbkJvYXJkQ2xpY2s/OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBXaGl0ZWJvYXJkKHsgc29ja2V0LCBzdHVkZW50SWQsIGNsYXNzQ29kZSwgaXNUZWFjaGVyLCBvbkJvYXJkQ2xpY2sgfTogV2hpdGVib2FyZFByb3BzKSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IFtpc0RyYXdpbmcsIHNldElzRHJhd2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjb2xvciwgc2V0Q29sb3JdID0gdXNlU3RhdGUoJyMwMDAwMDAnKTtcbiAgY29uc3QgW3Rvb2wsIHNldFRvb2xdID0gdXNlU3RhdGU8J2RyYXcnIHwgJ2VyYXNlJz4oJ2RyYXcnKTtcbiAgY29uc3QgW2xhc3RQb2ludCwgc2V0TGFzdFBvaW50XSA9IHVzZVN0YXRlPHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB8IG51bGw+KG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcblxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmICghY3R4KSByZXR1cm47XG5cbiAgICAvLyBTZXQgZml4ZWQgZGltZW5zaW9uc1xuICAgIGNvbnN0IHdpZHRoID0gODAwO1xuICAgIGNvbnN0IGhlaWdodCA9IDYwMDtcbiAgICBcbiAgICAvLyBTZXQgdGhlIGNhbnZhcyBzaXplIGluIGFjdHVhbCBwaXhlbHNcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIFxuICAgIC8vIFNldCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgY3R4LmZpbGxTdHlsZSA9ICcjZmZmZmZmJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAvLyBSZXF1ZXN0IGluaXRpYWwgY2FudmFzIHN0YXRlIGlmIHdlJ3JlIGEgdGVhY2hlciB2aWV3aW5nIGEgc3R1ZGVudCdzIGJvYXJkXG4gICAgaWYgKGlzVGVhY2hlcikge1xuICAgICAgc29ja2V0LmVtaXQoJ3JlcXVlc3QtY2FudmFzLXN0YXRlJywgeyBjbGFzc0NvZGUsIHN0dWRlbnRJZCB9KTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcmVjZWl2aW5nIGRyYXcgdXBkYXRlc1xuICAgIHNvY2tldC5vbignZHJhdy11cGRhdGUtcmVjZWl2ZWQnLCAoeyBzdHVkZW50SWQ6IGRyYXdpbmdTdHVkZW50SWQsIGRyYXdEYXRhLCBjYW52YXNTdGF0ZSB9KSA9PiB7XG4gICAgICBpZiAoZHJhd2luZ1N0dWRlbnRJZCA9PT0gc3R1ZGVudElkKSB7XG4gICAgICAgIGlmIChjYW52YXNTdGF0ZSkge1xuICAgICAgICAgIGxvYWRDYW52YXNTdGF0ZShjYW52YXNTdGF0ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZHJhd0RhdGEpIHtcbiAgICAgICAgICBkcmF3T25DYW52YXMoZHJhd0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgcmVjZWl2aW5nIGZ1bGwgY2FudmFzIHN0YXRlXG4gICAgc29ja2V0Lm9uKCdjYW52YXMtc3RhdGUtdXBkYXRlJywgKHsgc3R1ZGVudElkOiB1cGRhdGVkU3R1ZGVudElkLCBjYW52YXNTdGF0ZSB9KSA9PiB7XG4gICAgICBpZiAodXBkYXRlZFN0dWRlbnRJZCA9PT0gc3R1ZGVudElkICYmIGNhbnZhc1N0YXRlKSB7XG4gICAgICAgIGxvYWRDYW52YXNTdGF0ZShjYW52YXNTdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgbG9hZGluZyBzYXZlZCBjYW52YXMgc3RhdGVcbiAgICBzb2NrZXQub24oJ2xvYWQtY2FudmFzJywgKHsgc3R1ZGVudElkOiBsb2FkU3R1ZGVudElkLCBjYW52YXNEYXRhIH0pID0+IHtcbiAgICAgIGlmIChsb2FkU3R1ZGVudElkID09PSBzdHVkZW50SWQgJiYgY2FudmFzRGF0YSkge1xuICAgICAgICBsb2FkQ2FudmFzU3RhdGUoY2FudmFzRGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc29ja2V0Lm9mZignZHJhdy11cGRhdGUtcmVjZWl2ZWQnKTtcbiAgICAgIHNvY2tldC5vZmYoJ2NhbnZhcy1zdGF0ZS11cGRhdGUnKTtcbiAgICAgIHNvY2tldC5vZmYoJ2xvYWQtY2FudmFzJyk7XG4gICAgfTtcbiAgfSwgW3NvY2tldCwgc3R1ZGVudElkLCBjbGFzc0NvZGUsIGlzVGVhY2hlcl0pO1xuXG4gIGNvbnN0IGxvYWRDYW52YXNTdGF0ZSA9IChjYW52YXNTdGF0ZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzPy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmICghY2FudmFzIHx8ICFjdHgpIHJldHVybjtcblxuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICAgfTtcbiAgICBpbWcuc3JjID0gY2FudmFzU3RhdGU7XG4gIH07XG5cbiAgY29uc3QgZHJhd09uQ2FudmFzID0gKGRyYXdEYXRhOiBEcmF3RGF0YSkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcz8uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAoIWNhbnZhcyB8fCAhY3R4IHx8ICFkcmF3RGF0YT8ucG9pbnRzPy5sZW5ndGgpIHJldHVybjtcblxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKGRyYXdEYXRhLnBvaW50c1swXS54LCBkcmF3RGF0YS5wb2ludHNbMF0ueSk7XG5cbiAgICAvLyBTbW9vdGhlciBsaW5lIHdoZW4gZHJhd2luZ1xuICAgIGlmIChkcmF3RGF0YS50eXBlID09PSAnZXJhc2UnKSB7XG4gICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgwLDAsMCwxKSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZHJhd0RhdGEuY29sb3I7XG4gICAgfVxuXG4gICAgY3R4LmxpbmVXaWR0aCA9IDQ7IC8vIEluY3JlYXNlZCBsaW5lIHdpZHRoIGZvciBjbGFyaXR5XG4gICAgY3R4LmxpbmVDYXAgPSAncm91bmQnOyAvLyBSb3VuZGVkIGNhcCBmb3Igc21vb3RoIGVkZ2VzXG4gICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJzsgLy8gUm91bmRlZCBqb2lucyBmb3Igc21vb3RoIGNvcm5lcnNcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZHJhd0RhdGEucG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdHgubGluZVRvKGRyYXdEYXRhLnBvaW50c1tpXS54LCBkcmF3RGF0YS5wb2ludHNbaV0ueSk7XG4gICAgfVxuXG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgIC8vIFJlc2V0IGNvbXBvc2l0ZSBvcGVyYXRpb25cbiAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgfTtcblxuICBjb25zdCBnZXRDYW52YXNDb29yZGluYXRlcyA9IChlOiBSZWFjdC5Qb2ludGVyRXZlbnQpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHNjYWxlWCA9IGNhbnZhcy53aWR0aCAvIHJlY3Qud2lkdGg7XG4gICAgY29uc3Qgc2NhbGVZID0gY2FudmFzLmhlaWdodCAvIHJlY3QuaGVpZ2h0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IChlLmNsaWVudFggLSByZWN0LmxlZnQpICogc2NhbGVYLFxuICAgICAgeTogKGUuY2xpZW50WSAtIHJlY3QudG9wKSAqIHNjYWxlWVxuICAgIH07XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUG9pbnRlckRvd24gPSAoZTogUmVhY3QuUG9pbnRlckV2ZW50KSA9PiB7XG4gICAgaWYgKGlzVGVhY2hlcikge1xuICAgICAgaWYgKG9uQm9hcmRDbGljaykgb25Cb2FyZENsaWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29vcmRzID0gZ2V0Q2FudmFzQ29vcmRpbmF0ZXMoZSk7XG4gICAgaWYgKCFjb29yZHMpIHJldHVybjtcblxuICAgIHNldElzRHJhd2luZyh0cnVlKTtcbiAgICBzZXRMYXN0UG9pbnQoY29vcmRzKTtcblxuICAgIGNvbnN0IGRyYXdEYXRhOiBEcmF3RGF0YSA9IHtcbiAgICAgIHBvaW50czogW2Nvb3Jkc10sXG4gICAgICBjb2xvcjogdG9vbCA9PT0gJ2VyYXNlJyA/ICcjZmZmZmZmJyA6IGNvbG9yLFxuICAgICAgd2lkdGg6IDQsIC8vIFNldCB3aWR0aCB0byBtYXRjaCB0aGUgbmV3IGxpbmUgd2lkdGhcbiAgICAgIHR5cGU6IHRvb2xcbiAgICB9O1xuXG4gICAgZHJhd09uQ2FudmFzKGRyYXdEYXRhKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVQb2ludGVyTW92ZSA9IChlOiBSZWFjdC5Qb2ludGVyRXZlbnQpID0+IHtcbiAgICBpZiAoIWlzRHJhd2luZyB8fCBpc1RlYWNoZXIgfHwgIWxhc3RQb2ludCkgcmV0dXJuO1xuXG4gICAgY29uc3QgY29vcmRzID0gZ2V0Q2FudmFzQ29vcmRpbmF0ZXMoZSk7XG4gICAgaWYgKCFjb29yZHMpIHJldHVybjtcblxuICAgIGNvbnN0IGRyYXdEYXRhOiBEcmF3RGF0YSA9IHtcbiAgICAgIHBvaW50czogW2xhc3RQb2ludCwgY29vcmRzXSxcbiAgICAgIGNvbG9yOiB0b29sID09PSAnZXJhc2UnID8gJyNmZmZmZmYnIDogY29sb3IsXG4gICAgICB3aWR0aDogNCwgLy8gU2V0IHdpZHRoIHRvIG1hdGNoIHRoZSBuZXcgbGluZSB3aWR0aFxuICAgICAgdHlwZTogdG9vbFxuICAgIH07XG5cbiAgICBkcmF3T25DYW52YXMoZHJhd0RhdGEpO1xuXG4gICAgLy8gR2V0IGN1cnJlbnQgY2FudmFzIHN0YXRlXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY29uc3QgY2FudmFzU3RhdGUgPSBjYW52YXMudG9EYXRhVVJMKCk7XG5cbiAgICAgIC8vIEVtaXQgYm90aCB0aGUgZHJhdyBkYXRhIGFuZCBjYW52YXMgc3RhdGVcbiAgICAgIHNvY2tldC5lbWl0KCdkcmF3LXVwZGF0ZScsIHtcbiAgICAgICAgY2xhc3NDb2RlLFxuICAgICAgICBzdHVkZW50SWQsXG4gICAgICAgIGRyYXdEYXRhLFxuICAgICAgICBjYW52YXNTdGF0ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0TGFzdFBvaW50KGNvb3Jkcyk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUG9pbnRlclVwID0gKCkgPT4ge1xuICAgIHNldElzRHJhd2luZyhmYWxzZSk7XG4gICAgc2V0TGFzdFBvaW50KG51bGwpO1xuXG4gICAgLy8gU2VuZCBmaW5hbCBjYW52YXMgc3RhdGUgd2hlbiBkcmF3aW5nIGVuZHNcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoY2FudmFzICYmICFpc1RlYWNoZXIpIHtcbiAgICAgIGNvbnN0IGNhbnZhc1N0YXRlID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgICAgc29ja2V0LmVtaXQoJ2RyYXctdXBkYXRlJywge1xuICAgICAgICBjbGFzc0NvZGUsXG4gICAgICAgIHN0dWRlbnRJZCxcbiAgICAgICAgZHJhd0RhdGE6IG51bGwsXG4gICAgICAgIGNhbnZhc1N0YXRlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY2xlYXJDYW52YXMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzPy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmICghY2FudmFzIHx8ICFjdHgpIHJldHVybjtcblxuICAgIGN0eC5maWxsU3R5bGUgPSAnI2ZmZmZmZic7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAvLyBTZW5kIGNsZWFyZWQgY2FudmFzIHN0YXRlXG4gICAgY29uc3QgY2FudmFzU3RhdGUgPSBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgc29ja2V0LmVtaXQoJ2RyYXctdXBkYXRlJywge1xuICAgICAgY2xhc3NDb2RlLFxuICAgICAgc3R1ZGVudElkLFxuICAgICAgZHJhd0RhdGE6IG51bGwsXG4gICAgICBjYW52YXNTdGF0ZVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSBib3JkZXIgYm9yZGVyLWlucHV0IHJvdW5kZWQtbGcgc2hhZG93LW1kXCIgb25DbGljaz17b25Cb2FyZENsaWNrfT5cbiAgICAgIDxjYW52YXNcbiAgICAgICAgcmVmPXtjYW52YXNSZWZ9XG4gICAgICAgIGNsYXNzTmFtZT1cInRvdWNoLW5vbmUgdy1mdWxsIGgtZnVsbCByb3VuZGVkLWxnXCJcbiAgICAgICAgc3R5bGU9e3sgYXNwZWN0UmF0aW86ICc0LzMnIH19XG4gICAgICAgIG9uUG9pbnRlckRvd249e2hhbmRsZVBvaW50ZXJEb3dufVxuICAgICAgICBvblBvaW50ZXJNb3ZlPXtoYW5kbGVQb2ludGVyTW92ZX1cbiAgICAgICAgb25Qb2ludGVyVXA9e2hhbmRsZVBvaW50ZXJVcH1cbiAgICAgICAgb25Qb2ludGVyTGVhdmU9e2hhbmRsZVBvaW50ZXJVcH1cbiAgICAgIC8+XG4gICAgICB7IWlzVGVhY2hlciAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgYm90dG9tLTQgbGVmdC00IGZsZXggZ2FwLTIgYmctYmFja2dyb3VuZC85NSBiYWNrZHJvcC1ibHVyIHN1cHBvcnRzLVtiYWNrZHJvcC1maWx0ZXJdOmJnLWJhY2tncm91bmQvNjAgcC0yIHJvdW5kZWQtbGcgc2hhZG93LW1kIGJvcmRlciBib3JkZXItaW5wdXRcIj5cbiAgICAgICAgICB7LyogQ29sb3IgUGlja2VyLCBUb29sIFNlbGVjdGlvbiwgQ2xlYXIgQ2FudmFzICovfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJXaGl0ZWJvYXJkIiwic29ja2V0Iiwic3R1ZGVudElkIiwiY2xhc3NDb2RlIiwiaXNUZWFjaGVyIiwib25Cb2FyZENsaWNrIiwiY2FudmFzUmVmIiwiaXNEcmF3aW5nIiwic2V0SXNEcmF3aW5nIiwiY29sb3IiLCJzZXRDb2xvciIsInRvb2wiLCJzZXRUb29sIiwibGFzdFBvaW50Iiwic2V0TGFzdFBvaW50IiwiY2FudmFzIiwiY3VycmVudCIsImN0eCIsImdldENvbnRleHQiLCJ3aWR0aCIsImhlaWdodCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiZW1pdCIsIm9uIiwiZHJhd2luZ1N0dWRlbnRJZCIsImRyYXdEYXRhIiwiY2FudmFzU3RhdGUiLCJsb2FkQ2FudmFzU3RhdGUiLCJkcmF3T25DYW52YXMiLCJ1cGRhdGVkU3R1ZGVudElkIiwibG9hZFN0dWRlbnRJZCIsImNhbnZhc0RhdGEiLCJvZmYiLCJpbWciLCJJbWFnZSIsIm9ubG9hZCIsImNsZWFyUmVjdCIsImRyYXdJbWFnZSIsInNyYyIsInBvaW50cyIsImxlbmd0aCIsImJlZ2luUGF0aCIsIm1vdmVUbyIsIngiLCJ5IiwidHlwZSIsImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwibGluZUNhcCIsImxpbmVKb2luIiwiaSIsImxpbmVUbyIsInN0cm9rZSIsImNsb3NlUGF0aCIsImdldENhbnZhc0Nvb3JkaW5hdGVzIiwiZSIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzY2FsZVgiLCJzY2FsZVkiLCJjbGllbnRYIiwibGVmdCIsImNsaWVudFkiLCJ0b3AiLCJoYW5kbGVQb2ludGVyRG93biIsImNvb3JkcyIsImhhbmRsZVBvaW50ZXJNb3ZlIiwidG9EYXRhVVJMIiwiaGFuZGxlUG9pbnRlclVwIiwiY2xlYXJDYW52YXMiLCJkaXYiLCJjbGFzc05hbWUiLCJvbkNsaWNrIiwicmVmIiwic3R5bGUiLCJhc3BlY3RSYXRpbyIsIm9uUG9pbnRlckRvd24iLCJvblBvaW50ZXJNb3ZlIiwib25Qb2ludGVyVXAiLCJvblBvaW50ZXJMZWF2ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/Whiteboard.tsx\n"));

/***/ })

});